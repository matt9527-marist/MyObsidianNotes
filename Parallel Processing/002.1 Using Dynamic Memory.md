We had discussed *dangling references* previously. To avoid dangling references, we can use dynamic memory allocation. 

```c++
#include <iostream>
#include <string>
std::string& getName() {
	std::string *name = new std::string{"Alice"};
	return *name;
}
int main() {
	std::string& name{getName()};
	std::cout << "Hello " << name << "\n";
}
//Hello Alice
Using Dynamic Memory

```

`new` explicitly allocates memory, and even if the function completes, the memory will still be allocated. We are returning the reference `*name`

This illustrates the difference between heap memory and stack memory through the `new` keyword, handling the problem of the dangling reference. 

Another way is by returning **static references**. If a variable is `static`, that means the variable is global, and the memory is allocated for it until the entire program finishes executing. 

```c++
#include <iostream>  
int& activeUserCount() {  
	static int userCount{0};  
	userCount++;  
	return userCount;  
}  
int main() {  
	int& users = activeUserCount();  
	std::cout << "Active users: " << users << "\n"; // 1  
	users = 5;  
	std::cout << "Active users: " << users << "\n"; // 5  
	activeUserCount(); // Increments the count again  
	std::cout << "Active users: " << users << "\n"; // 6  
}
```

Here, we are simply once again returning the reference, except with using the `static` keyword to denote the global variable. This memory is also heap memory. 

These are 2 methods to avoid returning dangling references. 

If we ever get a WARNING from our compiler, for safety, we can convert these warnings to errors via: `g++ -std=c++23 -Werror main.cpp`

**Default Values** (must be part of header)
```c++
#include <iostream>  
//default must be part of header  
int boxVolume(int length=1, int width=1, int height=1);  

int main() {  
	int volume;  
	volume = boxVolume(); //1  
	//default must be rightmost  
	volume = boxVolume(10); //10  
	volume = boxVolume(10, 5); //50  
	volume = boxVolume(10, 5, 2); //100  
	std::cout << "\n";  
}  
int boxVolume(int l, int w, int h){  
	return l * w * h;  
}
```
Defaults used here mean that if no values are passed to be set to the object, the object will just use the default values. 
