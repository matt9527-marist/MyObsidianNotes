#Vectors will be used in a majority of the parallel programs we write in order to allow us to see the effects for longer periods of time. 

**Vector Container: Sequence of Elements**
```c++
#include <iostream>  
#include <vector>  
int main(){  
	std::vector<int> v1{1, 2, 3};  
	//using class template argument deduction (CTAD)  
	
	std::vector v2{1.1, 2.2, 3.3};  
	std::cout << v1[10] << "\n"; // No exception  
	std::cout << v1.at(10) << "\n"; //Exception  
}  
//clear && g++ -std=c++23 -Werror main.cpp && ./a.out  
/*  
0  
libc++abi: terminating due to uncaught exception of type std::out_of_range: vector  
zsh: abort ./a.out  
*/
```
The above program shows the error that occurs when trying to access an element out of range of the specified vector. 

**Printing Vectors: Range based `for`**
The following program shows how to print the elements of a vector.
```c++
#include <iostream>  
#include <vector>  
int main(){  
	//5 elements with each value as 1  
	std::vector vect(5, 1);  
	for(int i{0}; i<vect.size(); i++)  
		std::cout << vect[i] << " ";  
	std::cout << "\n";  
	for(int element : vect)  
		std::cout << element << " ";  
	std::cout << "\n";  
}
```

**2D Vectors**
```c++
#include <iostream>  
#include <vector>  
int main(){  
std::vector<std::vector<int>> v1{{1,2}, {3,4}};  
	for(const std::vector<int> &vect : v1){  
		for(const int &element : vect)  
			std::cout << element << " ";  
		std::cout << "\n";  
	}  
}
```
In the case of 2D vectors, we can print the elements by using references to the vector itself and to the elements inside.

## Constants and constexpr in C++

• const:
	• compile time initialization is not guaranteed, can be initialized
	at run-time
• constexpr:
	• compile time initialization is guaranteed, eliminating run-time
	initialization
• constexpr variable is implicitly const and is explicitly initialized at
compile time

`const`
• used to declare objects whose value cannot be changed after  
initialization  
• The value may be known at the run time  
• Using const prevents accidental modification, especially when it  
is passed-by-reference as a function argument.

```c++
#include <iostream>  
int someFunc(int i){  
	return i + 1;  
}  
int main() {  
	const int a{5}; // initialize  
	const int b{someFunc(2)}; // run time  
	//a++; // compile error  
	//b++; // compile error  
	std::cout << a << " " << b << "\n"; // 5 3  
}
```
Above, we try to increment the value of a `const`, which throws a compile error. 
This is because the values should be constant throughout the execution. 

```c++
#include <iostream>  
int someFunc(int i){  
	return i + 1;  
}  
int main() {  
	const int a{5}; // initialize  
	//constexpr int b{someFunc(2)}; // error  
	//a++; // compile error  
	//b++; // compile error  
	std::cout << a << "\n"; // 5  
}
```